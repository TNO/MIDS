/////////////////////////////////////////////////////////////////////////
// Copyright (c) 2018-2024 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available
// under the terms of the MIT License which is available at
// https://opensource.org/licenses/MIT
//
// SPDX-License-Identifier: MIT
/////////////////////////////////////////////////////////////////////////

package nl.tno.mids.compare.data;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.escet.common.java.Assert;

import net.automatalib.commons.util.Pair;

/** Data concerning an entity present in model sets. */
public class Entity implements Comparable<Entity> {
    /** Is {@code -1} if not yet determined. */
    private int number = -1;

    private final String name;

    private final List<Model> models = new ArrayList<>();

    private final List<Variant<Model>> variants = new ArrayList<>();

    private final List<LatticeNode<Variant<Model>>> lattice = new ArrayList<>();

    private final List<Pair<Variant<Model>, Variant<Model>>> structuralDiffPairs = new ArrayList<>();

    private boolean latticeIncomplete = false;

    private int nextVariant = 1;

    Entity(String name) {
        this.name = name;
    }

    /**
     * Register a {@link Model} that describes this entity.
     * 
     * @param model Model to register.
     */
    public void addModel(Model model) {
        models.add(model);
    }

    /**
     * Register a new behavior variant for this entity.
     * 
     * @param model Model describing the behavior of this variant.
     * @param computed Whether the model was generated by the compare tool ({@code true}) or an input model
     *     ({@code false}).
     * @return Variant for the new variant.
     */
    public Variant<Model> addVariant(Model model, boolean computed) {
        if (!model.hasBehavior()) {
            Variant<Model> variant = new Variant<>(0, model, model.getModelSize(), computed);
            variants.add(variant);
            model.setVariant(variant);
            return variant;
        }
        Variant<Model> variant = new Variant<>(nextVariant, model, model.getModelSize(), computed);
        variants.add(variant);
        model.setVariant(variant);
        nextVariant += 1;
        return variant;
    }

    /**
     * @return The entity number.
     */
    public int getNumber() {
        Assert.check(number >= 1);
        return number;
    }

    /**
     * @param number The entity number to set.
     */
    void setNumber(int number) {
        Assert.check(this.number == -1, "Number is " + this.number);
        this.number = number;
    }

    /**
     * @return The entity name.
     */
    public String getName() {
        return name;
    }

    /**
     * @return The lattice relating model variants for this entity.
     */
    public List<LatticeNode<Variant<Model>>> getLattice() {
        return lattice;
    }

    /**
     * @return The relevant lattice nodes for display purposes, i.e. lattice nodes with behavior or connecting multiple
     *     other lattice nodes.
     */
    public List<LatticeNode<Variant<Model>>> getLatticeNodesToDisplay() {
        return lattice.stream().filter(
                latticeNode -> latticeNode.getValue().getValue().hasBehavior() || latticeNode.getChildren().size() > 1)
                .collect(Collectors.toList());
    }

    /**
     * @return The models for this entity.
     */
    public List<Model> getModels() {
        return models;
    }

    /**
     * @return The variants for this entity.
     */
    public List<Variant<Model>> getVariants() {
        return variants;
    }

    /**
     * @return The variants with behavior for this entity.
     */
    public List<Variant<Model>> getVariantsWithBehavior() {
        return variants.stream().filter(variant -> variant.getValue().hasBehavior()).collect(Collectors.toList());
    }

    /**
     * Store that structural differences have been created for a pair of variants of this entity.
     * 
     * @param left Left variant involved in the compare.
     * @param right Right variant involved in the compare.
     */
    public void addStructuralDifferencePair(Variant<Model> left, Variant<Model> right) {
        structuralDiffPairs.add(Pair.of(left, right));
    }

    /**
     * @return List of pairs of variants of this entity with structural compare results.
     */
    public List<Pair<Variant<Model>, Variant<Model>>> getStructuralDifferencePairs() {
        return structuralDiffPairs;
    }

    /**
     * @return {@code true} if the variants of this entity do not form a complete lattice, {@code false} otherwise.
     */
    public boolean isLatticeIncomplete() {
        return latticeIncomplete;
    }

    /**
     * Mark variant lattice of entity as incomplete.
     */
    public void setLatticeIncomplete() {
        latticeIncomplete = true;
    }

    @Override
    public int compareTo(Entity otherEntity) {
        return this.name.compareTo(otherEntity.name);
    }
}
